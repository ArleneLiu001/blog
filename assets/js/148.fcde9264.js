(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{492:function(a,n,t){"use strict";t.r(n);var e=t(18),r=Object(e.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h3",{attrs:{id:"函数表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数表达式"}},[a._v("#")]),a._v(" 函数表达式")]),a._v(" "),n("p",[a._v("定义函数方式：1.函数表达式 。2.函数声明"),n("br"),a._v("\n浏览器在解析一个函数的时候，默认一个name属性，如果name属性为空，则是匿名函数。\n函数声明特征：会函数声明提升。但是函数表达式不会。不能在表达式之前调用函数。例如:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("sayHi() //错误：函数还不存在\nvar sayHi = function(){}\n")])])]),n("h3",{attrs:{id:"递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[a._v("#")]),a._v(" 递归:")]),a._v(" "),n("ol",[n("li",[a._v("递归经典形式：")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function factory(num){\n    if(num<=1){\n        return 1\n    }else{\n        return num*factory(num-1);\n    }\n}\n")])])]),n("p",[a._v("此种情况，如果把var a=factory ;factory= null。则调用a(4)就会报错。解决方式：\n1.arguments.callee :是一个指向正在执行的函数的指针。因此用它来代替函数名实现对函数的递归调用：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function factory(num){\n     if(num<=1){\n         return 1\n     }else{\n         return num*arguments.callee(num-1);\n     }\n }\n")])])]),n("p",[a._v("缺点：严格模式下会报错。\n2. 使用命名函数表达式：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a= (factory(num){\n     if(num<=1){\n         return 1\n     }else{\n         return num*factory(num-1);\n     }\n })\n")])])]),n("p",[a._v("优点：兼容严格模式和非严格模式。")])])}),[],!1,null,null,null);n.default=r.exports}}]);